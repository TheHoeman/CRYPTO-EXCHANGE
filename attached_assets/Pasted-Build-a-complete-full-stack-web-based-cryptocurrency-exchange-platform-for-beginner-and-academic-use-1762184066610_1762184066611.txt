Build a complete full-stack web-based cryptocurrency exchange platform for beginner and academic users using React.js for the frontend with Tailwind CSS, Node.js with Express.js for the backend, and SQLite or PostgreSQL for the database. Implement JWT-based authentication with bcrypt password hashing, integrate CoinGecko API or CryptoCompare API for real-time crypto prices, and use Recharts or Chart.js for portfolio visualization.
Structure the project with a client folder containing the React frontend with components, pages, context, and utils subdirectories, and a server folder containing the Node.js backend with routes, controllers, models, middleware, and utils subdirectories. Include a database folder with schema.sql.
For the authentication system, implement user registration with email validation, secure login with JWT tokens, password hashing using bcrypt with minimum 8 characters including uppercase, lowercase, and numbers, session management with token expiration, and logout functionality. Create a users table with id as primary key, unique email, password_hash, created_at timestamp, and is_admin boolean defaulting to false. Build endpoints for POST /api/auth/register, POST /api/auth/login, POST /api/auth/logout, and GET /api/auth/verify.
For crypto wallet management, display wallet balances for Bitcoin and Ethereum, create deposit and withdrawal interfaces with balance validation, and implement real-time balance updates. Create a wallets table with id as primary key, user_id as foreign key to users, currency for BTC or ETH, balance as decimal defaulting to 0, and created_at timestamp. Build endpoints for GET /api/wallet/balance, POST /api/wallet/deposit, and POST /api/wallet/withdraw.
For the trading system, create a buy/sell interface with real-time price display, implement order placement with balance validation, build an automatic order matching system by price and timestamp, support market orders with instant execution at current price, and update live prices from the crypto API every 30 seconds. Create an orders table with id as primary key, user_id as foreign key, order_type for BUY or SELL, currency for BTC or ETH, amount and price as decimals, status for PENDING, COMPLETED, or CANCELLED, is_sandbox boolean defaulting to false, created_at and completed_at timestamps. Also create a trades table with id as primary key, buy_order_id and sell_order_id as foreign keys to orders, currency, amount and price as decimals, and executed_at timestamp. Build endpoints for GET /api/prices to fetch current crypto prices, POST /api/orders/buy, POST /api/orders/sell, GET /api/orders/active, and POST /api/orders/cancel/:id.
For transaction history, display a chronologically sorted list of all user trades with filters by currency, type, and date range, include export functionality for CSV download, and implement pagination for large datasets. Build endpoints for GET /api/transactions/history with query parameters for page, limit, and currency, and GET /api/transactions/export.
For trading sandbox mode, implement a toggle between real and sandbox mode, provide a virtual starting balance of $10,000 equivalent in BTC and ETH, ensure sandbox trades use real-time prices but don't affect real balances, add a reset sandbox balance button, and display clear visual indicators when in sandbox mode. Create a sandbox_wallets table with id as primary key, user_id as foreign key, currency for BTC or ETH, balance as decimal, and updated_at timestamp. Build endpoints for GET /api/sandbox/balance, POST /api/sandbox/reset, and POST /api/sandbox/trade.
For manual copy trading, create a public leaderboard showing top traders by profit percentage, display trader stats including total trades, win rate, and profit/loss, implement functionality to view individual trader's trade history, add a manual copy button to replicate specific trades, and provide real-time updates of leaderboard rankings. Create a trader_stats table with id as primary key, user_id as foreign key, username for display, total_trades and profitable_trades as integers, total_profit_loss and roi_percentage as decimals, and updated_at timestamp. Build endpoints for GET /api/leaderboard with a limit query parameter, GET /api/traders/:id/history, and POST /api/copy-trade.
For the portfolio dashboard, display a pie chart showing portfolio allocation between BTC, ETH, and cash, create a line chart showing portfolio value over time with options for 7 days, 30 days, 90 days, and 1 year, show current total portfolio value in USD, display percentage gain/loss indicators, include an asset-wise breakdown table, and implement real-time value updates. Create a portfolio_snapshots table with id as primary key, user_id as foreign key, total_value_usd, btc_amount, and eth_amount as decimals, and snapshot_date timestamp. Build endpoints for GET /api/portfolio/current, GET /api/portfolio/history with a period query parameter, and GET /api/portfolio/allocation.
Create frontend pages for authentication at /register and /login, a dashboard at /dashboard showing overview with quick stats, recent trades, and portfolio summary, trading pages at /trade for the main trading interface with buy/sell forms and /orders for active and completed orders, a wallet page at /wallet for balances and deposit/withdraw interface, a history page at /history for complete transaction history with filters, a portfolio page at /portfolio for detailed analytics with charts, copy trading pages at /leaderboard for trader rankings and /trader/:id for individual trader profiles, and a sandbox page at /sandbox for dedicated sandbox tutorial and info with the toggle available on all trading pages.
Implement real-time price updates by polling the API every 30 seconds using useEffect in the frontend. Create a simple FIFO order matching algorithm in the backend that finds opposite orders, matches by best price then earliest timestamp, executes trades and updates balances, and marks orders as completed.
Ensure all security requirements are met by hashing all passwords with bcrypt using 10 salt rounds minimum, setting JWT tokens to expire after 24 hours, requiring HTTPS which Replit handles automatically, validating all form inputs, preventing SQL injection using parameterized queries, and implementing rate limiting of 100 requests per 15 minutes per user on API endpoints.
Meet performance requirements by supporting 10-20 concurrent users, ensuring API responses under 2 seconds, optimizing database queries with indexes, and implementing lazy loading for transaction history pagination.
Implement business rules that users must be logged in to trade or withdraw, users cannot sell more than their current balance, minimum trade amounts are 0.001 BTC or 0.01 ETH, withdrawal limits are maximum $10,000 equivalent per 24 hours, and sessions expire after 60 minutes of inactivity.
Design a clean, modern interface using Tailwind CSS with a responsive mobile-friendly design, professional color scheme using blues and greens for the crypto theme, proper accessibility with labels, ARIA tags, and keyboard navigation, loading states with spinners during API calls, user-friendly error messages, and toast notifications for successful actions.
Follow this step-by-step implementation: First, initialize the Replit project with React and Node.js, set up the Express server with basic routing, create the database and schema, implement user registration with validation, implement login with JWT, create protected route middleware, and build login and registration UI components. Second, integrate CoinGecko API for price fetching, create wallet models and endpoints, build wallet UI with balance display, implement deposit/withdraw functionality, create the trading interface with buy/sell forms, implement order placement logic, and build the basic order matching engine. Third, create the transaction history endpoint with pagination, build transaction history UI with filters, create the main dashboard with stats overview, and add a recent trades widget to the dashboard. Fourth, create sandbox wallet tables, implement the sandbox mode toggle, build sandbox reset functionality, add visual indicators for sandbox mode, and test sandbox isolation from real trades. Fifth, create trader stats calculation logic, build the leaderboard endpoint and UI component, implement trader profile pages, and build copy trade functionality. Sixth, create the portfolio snapshot system, build portfolio calculation logic, integrate Recharts for visualizations, create pie chart for allocation, create line chart for historical value, and add real-time value updates. Finally, add loading states and error handling, implement toast notifications, add responsive design touches, write comprehensive tests, fix bugs and optimize, and deploy and document.
Use async/await for all asynchronous operations, implement proper error handling with try-catch blocks, log important events like trades, deposits, and withdrawals, add comments for complex logic, follow REST API conventions, keep components modular and reusable, use environment variables for sensitive data including DATABASE_URL, JWT_SECRET, CRYPTO_API_KEY, PORT set to 3000, NODE_ENV set to development, and SESSION_TIMEOUT set to 3600000, and implement daily database backups as a mock for demo purposes.
Ensure the application meets success criteria where users can register, login, and manage sessions, real-time crypto prices display and update, users can buy and sell crypto with balance validation, order matching works automatically, transaction history is complete and filterable, sandbox mode works independently from real trading, the leaderboard shows top traders accurately, copy trading allows manual trade replication, the portfolio dashboard shows beautiful accurate charts, the application is responsive and works on mobile, all security requirements are met including hashing, JWT, and HTTPS, and performance meets requirements with under 2 second response times for 10-20 concurrent users.